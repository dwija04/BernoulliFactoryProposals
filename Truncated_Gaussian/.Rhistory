{
plot(density(chain1[, i]), col = "blue", main = paste("Chain", i))
lines(density(chain2[, i]), col = "red")
}
plot(density(chain1[, 2]), col = "blue")
lines(density(chain2[, 2]), col = "red")
# par(mfrow = c(5, 2))
for(i in 1:10)
plot(density(chain1[, 2]), col = "blue")
lines(density(chain2[, 2]), col = "red")
plot(density(chain1[, 9]), col = "blue", xlim = c(0, 0.4))
lines(density(chain2[, 9]), col = "red")
plot(density(chain1[, 10]), col = "blue", xlim = c(0, 0.4))
lines(density(chain2[, 10]), col = "red")
#target distribution
pi <- function(x, alpha, beta)
{
ret <- x^(alpha-1) * exp(-beta*x)
return(ret)
}
#function to calculate the bounds
C_f <- function(x, alpha, beta)
{
ret <- x^(alpha - 1) * exp((-1)*beta*x)
return(ret)
}
#indicator function
ind <- function(t, x)
{
if(t < x) {ret <- 1}
else {ret <- 0}
return(ret)
}
#Running the MCMC chain with exact proposals using Bernoulli factories
BF_trunc_norm <- function(n, alpha = 2, beta = 1, var = 100, init)
{
x <- numeric(n)
x[1] <- init
loops_total <- numeric(n)
accept_rate <- 0
for(i in 2:n)
{
y <- rtruncnorm(1, a = 0, b = Inf, mean = x[i-1], sd = sqrt(var))
#calculating the bounds
c_x <- C_f(y, alpha, beta)
c_y <- C_f(x[i-1], alpha, beta)
C <- c_x / (c_y + c_x)
accept <-0
loops <- 0
#running the Bernoulli factory
while(!accept)
{
loops <- loops + 1
C1 <- rbinom(1, 1, C)
if(C1 == 1)
{
M <- rnorm(1, mean = 0, sd = sqrt(var))
p_x <- ind(M, x[i-1])
C2 <- rbinom(1, 1, p_x)
if(C2 == 1)
{
x[i+1] <- y
accept <- 1
accept_rate <- accept_rate + 1
}
}
else
{
M <- rnorm(1, mean = 0, sd = sqrt(var))
p_y <- ind(M, y)
C2 <- rbinom(1, 1, p_y)
if(C2 == 1)
{
x[i+1] <- x[i]
accept <- 1
}
}
}
loops_total[i] <- loops
}
return(c(x, loops_total, accept_rate/n))
}
#Running MCMC chain with approximate proposals using Metropolis Hastings
MH_truncnorm <- function(n, alpha = 2, beta = 1, var = 100, init)
{
x <- numeric(n)
x[1] <- init
accept <- 0
for(i in 2:n)
{
y <- rtruncnorm(1, a = 0, b = Inf, mean = x[i-1], sd = sqrt(var))
#Evaluating MH ratio
ratio <- (dgamma(y, shape = alpha, rate = beta) * dtruncnorm(x[i-1], a = 0, b = Inf, mean = y, sd = sqrt(var))) /
(dgamma(x[i-1], shape = alpha, rate = beta) * dtruncnorm(y, a = 0, b = Inf, mean = x[i-1], sd = sqrt(var)))
acceptance_prob <- min(1, ratio)
if(runif(1) < acceptance_prob) {
x[i] <- y
accept <- accept + 1
} else {
x[i] <- x[i-1]
}
}
return(c(x, accept / n))
}
m <- 1e6
m <- 1e5
#Samples using exact proposals
foo1 <- replicate(1, BF_trunc_norm(m, init = 1))
library(truncnorm)
library(mcmcse)
foo <- BF_trunc_norm(m, init = 1)
foo[[2  ]]
foo[[2]]
foo[[3]]
#Samples using exact proposals
foo1 <- replicate(10, BF_trunc_norm(m, init = 1))
foo <- BF_trunc_norm(m, init = 1)
foo[[1]]
foo
foo[1]
length(foo)
foo[2*m + 1] #loops
foo[2*m + 2] #acceptance rate
#Samples using exact proposals
foo1 <- replicate(10, BF_trunc_norm(m, var = 50, init = 1))
m <- 1e5
#Samples using exact proposals
foo1 <- replicate(10, BF_trunc_norm(m, var = 75, init = 1))
#Samples using exact proposals
foo1 <- replicate(10, BF_trunc_norm(m, var = 75, init = 1))
foo <- BF_trunc_norm(m, var = 75, init = 1)
foo[2*m + 1] #loops
foo[2*m + 2] #acceptance rate
foo <- BF_trunc_norm(m, var = 50, init = 1)
foo[2*m + 1] #loops
foo[2*m + 2] #acceptance rate
foo <- BF_trunc_norm(m, var = 25, init = 1)
foo[2*m + 1] #loops
foo[2*m + 2] #acceptance rate
foo <- BF_trunc_norm(m, var = 25, init = 1)
foo[2*m + 1] #loops
foo[2*m + 2] #acceptance rate
average_ess_exact <- round(mean(apply(samples1, 2, ess)), 4)
load("truncated-normal-proposal-Bern.RData")
load("truncated-normal-proposal-MH.RData")
library(mcmcse)
temp <- dim(foo1)
m <- (temp[1] - 2)/2
#Samples from MCMC using exact proposals
samples1 <- foo1[1:m+1, ]
loops <- foo1[(m+2):(2*m+1), ]
# average loops over all runs
average_loops <- round(mean(loops), 4)
average_max_loops <- mean(apply(loops, 2, max))
print(paste('The average Bernoulli loops are:', average_loops))
print(paste('The average of max Bernoulli loops in a chain are:', average_max_loops))
average_ess_exact <- round(mean(apply(samples1, 2, ess)), 4)
print(paste('The average ESS for exact proposal is:', average_ess_exact))
print(paste('The average ESS for approximate proposal is:', average_ess_approx))
#Effective Sample Size
average_ess_exact <- round(mean(apply(samples1, 2, ess)), 4)
average_ess_approx <- round(mean(apply(samples2, 2, ess)), 4)
print(paste('The average ESS for exact proposal is:', average_ess_exact))
print(paste('The average ESS for approximate proposal is:', average_ess_approx))
#Density Plots
x <- seq(0, 10, 0.01)
#Samples from MCMC using exact proposals
samples1 <- foo1[1:m+1, ]
loops <- foo1[(m+2):(2*m+1), ]
#Samples from MCMC using approximate proposals
samples2 <- foo2[1:m, ]
# average loops over all runs
average_loops <- round(mean(loops), 4)
average_max_loops <- mean(apply(loops, 2, max))
print(paste('The average Bernoulli loops are:', average_loops))
print(paste('The average of max Bernoulli loops in a chain are:', average_max_loops))
#Effective Sample Size
average_ess_exact <- round(mean(apply(samples1, 2, ess)), 4)
average_ess_approx <- round(mean(apply(samples2, 2, ess)), 4)
load("truncated-normal-proposal-Bern.RData")
load("truncated-normal-proposal-MH.RData")
library(mcmcse)
temp <- dim(foo1)
m <- (temp[1] - 2)/2
#Samples from MCMC using exact proposals
samples1 <- foo1[1:m+1, ]
loops <- foo1[(m+2):(2*m+1), ]
#Samples from MCMC using approximate proposals
samples2 <- foo2[1:m, ]
# average loops over all runs
average_loops <- round(mean(loops), 4)
average_max_loops <- mean(apply(loops, 2, max))
print(paste('The average Bernoulli loops are:', average_loops))
print(paste('The average of max Bernoulli loops in a chain are:', average_max_loops))
#Effective Sample Size
average_ess_exact <- round(mean(apply(samples1, 2, ess)), 4)
average_ess_approx <- round(mean(apply(samples2, 2, ess)), 4)
print(paste('The average ESS for exact proposal is:', average_ess_exact))
print(paste('The average ESS for approximate proposal is:', average_ess_approx))
#Density Plots
x <- seq(0, 10, 0.01)
library(truncnorm)
library(mcmcse)
#Gamma (2, 1) target distribution
pi <- function(x, alpha, beta)
{
ret <- x^(alpha-1) * exp(-beta*x)
return(ret)
}
#function to calculate the bounds
C_f <- function(x, alpha, beta)
{
ret <- x^(alpha - 1) * exp((-1)*beta*x)
return(ret)
}
#indicator function
ind <- function(t, x)
{
if(t < x) {ret <- 1}
else {ret <- 0}
return(ret)
}
#Running the MCMC chain with exact proposals using Bernoulli factories
BF_trunc_norm <- function(n, alpha = 2, beta = 1, var, init)
{
x <- numeric(n)
x[1] <- init
loops_total <- numeric(n)
accept_rate <- 0
for(i in 2:n)
{
y <- rtruncnorm(1, a = 0, b = Inf, mean = x[i-1], sd = sqrt(var))
#calculating the bounds
c_x <- C_f(y, alpha, beta)
c_y <- C_f(x[i-1], alpha, beta)
C <- c_x / (c_y + c_x)
accept <-0
loops <- 0
#running the Bernoulli factory
while(!accept)
{
loops <- loops + 1
C1 <- rbinom(1, 1, C)
if(C1 == 1)
{
M <- rnorm(1, mean = x[i-1], sd = sqrt(var))
p_x <- (M > 0) #ind(M, x[i-1])
# C2 <- rbinom(1, 1, p_x)
if(p_x== 1)
{
x[i] <- y
accept <- 1
accept_rate <- accept_rate + 1
}
}
else
{
M <- rnorm(1, mean = y, sd = sqrt(var))
p_y <- (M > 0) #ind(M, y)
# C2 <- rbinom(1, 1, p_y)
if(p_y == 1)
{
x[i] <- x[i-1]
accept <- 1
}
}
}
loops_total[i] <- loops
}
return(c(x, loops_total, accept_rate/n))
}
#Running MCMC chain with approximate proposals using Metropolis Hastings
MH_truncnorm <- function(n, alpha = 2, beta = 1,var, init)
{
x <- numeric(n)
x[1] <- init
accept <- 0
for(i in 2:n)
{
y <- rtruncnorm(1, a = 0, b = Inf, mean = x[i-1], sd = sqrt(var))
#Evaluating MH ratio
ratio <- (dgamma(y, shape = alpha, rate = beta) * dtruncnorm(x[i-1], a = 0, b = Inf, mean = y, sd = sqrt(var))) /
(dgamma(x[i-1], shape = alpha, rate = beta) * dtruncnorm(y, a = 0, b = Inf, mean = x[i-1], sd = sqrt(var)))
acceptance_prob <- min(1, ratio)
if(runif(1) < acceptance_prob) {
x[i] <- y
accept <- accept + 1
} else {
x[i] <- x[i-1]
}
}
return(c(x, accept/n))
}
library(truncnorm)
library(mcmcse)
#Gamma (2, 1) target distribution
pi <- function(x, alpha, beta)
{
ret <- x^(alpha-1) * exp(-beta*x)
return(ret)
}
#function to calculate the bounds
C_f <- function(x, alpha, beta)
{
ret <- x^(alpha - 1) * exp((-1)*beta*x)
return(ret)
}
#indicator function
ind <- function(t, x)
{
if(t < x) {ret <- 1}
else {ret <- 0}
return(ret)
}
#Running the MCMC chain with exact proposals using Bernoulli factories
BF_trunc_norm <- function(n, alpha = 2, beta = 1, var, init)
{
x <- numeric(n)
x[1] <- init
loops_total <- numeric(n)
accept_rate <- 0
for(i in 2:n)
{
y <- rtruncnorm(1, a = 0, b = Inf, mean = x[i-1], sd = sqrt(var))
#calculating the bounds
c_x <- C_f(y, alpha, beta)
c_y <- C_f(x[i-1], alpha, beta)
C <- c_x / (c_y + c_x)
accept <-0
loops <- 0
#running the Bernoulli factory
while(!accept)
{
loops <- loops + 1
C1 <- rbinom(1, 1, C)
if(C1 == 1)
{
M <- rnorm(1, mean = x[i-1], sd = sqrt(var))
p_x <- (M > 0) #ind(M, x[i-1])
# C2 <- rbinom(1, 1, p_x)
if(p_x== 1)
{
x[i] <- y
accept <- 1
accept_rate <- accept_rate + 1
}
}
else
{
M <- rnorm(1, mean = y, sd = sqrt(var))
p_y <- (M > 0) #ind(M, y)
# C2 <- rbinom(1, 1, p_y)
if(p_y == 1)
{
x[i] <- x[i-1]
accept <- 1
}
}
}
loops_total[i] <- loops
}
return(c(x, loops_total, accept_rate/n))
}
#Running MCMC chain with approximate proposals using Metropolis Hastings
MH_truncnorm <- function(n, alpha = 2, beta = 1,var, init)
{
x <- numeric(n)
x[1] <- init
accept <- 0
for(i in 2:n)
{
y <- rtruncnorm(1, a = 0, b = Inf, mean = x[i-1], sd = sqrt(var))
#Evaluating MH ratio
ratio <- (dgamma(y, shape = alpha, rate = beta) * dtruncnorm(x[i-1], a = 0, b = Inf, mean = y, sd = sqrt(var))) /
(dgamma(x[i-1], shape = alpha, rate = beta) * dtruncnorm(y, a = 0, b = Inf, mean = x[i-1], sd = sqrt(var)))
acceptance_prob <- min(1, ratio)
if(runif(1) < acceptance_prob) {
x[i] <- y
accept <- accept + 1
} else {
x[i] <- x[i-1]
}
}
return(c(x, accept/n))
}
getwd()
setwd("/Users/dwijakakkad/Desktop/MCMC/Bernoulli factory proposals/Truncated_Gaussian")
load("output_trunc_gaussian.RData")
##########################################
# Replications output
##########################################
#Extracting the output
reps <- length(output_trunc_gaussian)
bf_time <- numeric(reps)
mh_time <- numeric(reps)
bf_loops_mean <- numeric(reps)
bf_loops_max <- numeric(reps)
bf_ess <- numeric(reps)
mh_ess <- numeric(reps)
for(i in 1:reps)
{
bf_time[i] <- output_trunc_gaussian[[i]][[1]][[3]]
mh_time[i] <- output_trunc_gaussian[[i]][[2]][[3]]
bf_loops_mean[i] <- output_trunc_gaussian[[i]][[3]]
bf_loops_max[i] <- output_trunc_gaussian[[i]][[4]]
bf_ess[i] <- output_trunc_gaussian[[i]][[5]]
mh_ess[i] <- output_trunc_gaussian[[i]][[6]]
}
#Loops
avg_bf_loops_mean <- round(mean(bf_loops_mean), 2)
avg_bf_loops_max <- round(mean(bf_loops_max), 2)
bernoulli_df <- data.frame(
Metric = c("Average Loops", "Maximum Loops"),
Bernoulli_factory = c(avg_bf_loops_mean, avg_bf_loops_max)
)
print(bernoulli_df)
avg_bf_ess <- round(mean(bf_ess))
avg_mh_ess <- round(mean(mh_ess))
avg_bf_ess_time <- round(mean(bf_ess/bf_time))
avg_mh_ess_time <- round(mean(mh_ess/mh_time))
ess_df <- data.frame(
Metric = c("Effective Sample Size (ESS)", "ESS per unit time", "Average computing time"),
Exact_proposal = c(avg_bf_ess, avg_bf_ess_time, round(mean(bf_time), 2)),
Approximate_proposal = c(avg_mh_ess, avg_mh_ess_time, round(mean(mh_time), 2))
)
print(ess_df)
#Average computing times
print(mean(round(bf_time, 2)))
print(mean(round(mh_time, 2)))
##########################################
## Single chain plots
##########################################
load("output_trunc_gaussian_single_run.RData")
pdf("plots/trunc_gauss_density.pdf")
x <- seq(0, 15, 0.01)
plot(density(bf_chain[[1]]), ylim = c(0, .4),
col = "blue", main = " ", xlab = "x")
legend("topright", legend = c("Target density", "Bernoulli factory MCMC", "Approximate Metropolis-Hastings") ,
col = c("black","blue","red"), lty = c(1, 1, 1),
cex = 1.5, bty = "n")
x <- seq(0, 15, 0.01)
plot(density(bf_chain[[1]]), ylim = c(0, .4),
col = "blue", main = " ", xlab = "x")
lines(density(mh_chain[[1]]), col = "red")
lines(x, dgamma(x, shape = 2, rate = 1), col = "black")
legend("topright", legend = c("Target density", "Bernoulli factory MCMC", "Approximate Metropolis-Hastings") ,
col = c("black","blue","red"), lty = c(1, 1, 1),
cex = 1.5, bty = "n")
plot(density(bf_chain[[1]]), ylim = c(0, .4), col = "blue", main = " ", xlab = "x")
plot(density(bf_chain[[1]]), ylim = c(0, .4), col = "blue", main = " ", xlab = "x")
lines(density(mh_chain[[1]]), col = "red")
lines(x, dgamma(x, shape = 2, rate = 1), col = "black")
legend("topright", legend = c("Target density", "Bernoulli factory MCMC", "Approximate Metropolis-Hastings") ,
col = c("black","blue","red"), lty = c(1, 1, 1),
cex = 1.5, bty = "n")
lag.max <- 40
mh_acf <- acf(mh_chain[[1]], lag.max = lag.max , plot = FALSE)$acf
bf_acf <- acf(bf_chain[[1]], lag.max = lag.max , plot = FALSE)$acf
plot(0:lag.max , mh_acf, type = 'l', col = "red",
ylab = "Estimated Autocorrelation Function", xlab = "Lags")
lines(0:lag.max , bf_acf, col = "blue")
legend("topright", legend = c("Bernoulli factory MCMC", "Approximate Metropolis-Hastings") ,
col = c("blue","red"), lty = c(1, 1, 1),
cex = 1.5, bty = "n")
load("output_trunc_gaussian.RData")
##########################################
# Replications output
##########################################
#Extracting the output
reps <- length(output_trunc_gaussian)
bf_time <- numeric(reps)
mh_time <- numeric(reps)
bf_loops_mean <- numeric(reps)
bf_loops_max <- numeric(reps)
bf_ess <- numeric(reps)
mh_ess <- numeric(reps)
for(i in 1:reps)
{
bf_time[i] <- output_trunc_gaussian[[i]][[1]][[3]]
mh_time[i] <- output_trunc_gaussian[[i]][[2]][[3]]
bf_loops_mean[i] <- output_trunc_gaussian[[i]][[3]]
bf_loops_max[i] <- output_trunc_gaussian[[i]][[4]]
bf_ess[i] <- output_trunc_gaussian[[i]][[5]]
mh_ess[i] <- output_trunc_gaussian[[i]][[6]]
}
#Loops
avg_bf_loops_mean <- round(mean(bf_loops_mean), 2)
avg_bf_loops_max <- round(mean(bf_loops_max), 2)
bernoulli_df <- data.frame(
Metric = c("Average Loops", "Maximum Loops"),
Bernoulli_factory = c(avg_bf_loops_mean, avg_bf_loops_max)
)
print(bernoulli_df)
avg_bf_ess <- round(mean(bf_ess))
avg_mh_ess <- round(mean(mh_ess))
avg_bf_ess_time <- round(mean(bf_ess/bf_time))
avg_mh_ess_time <- round(mean(mh_ess/mh_time))
ess_df <- data.frame(
Metric = c("Effective Sample Size (ESS)", "ESS per unit time", "Average computing time"),
Exact_proposal = c(avg_bf_ess, avg_bf_ess_time, round(mean(bf_time), 2)),
Approximate_proposal = c(avg_mh_ess, avg_mh_ess_time, round(mean(mh_time), 2))
)
print(ess_df)
#Average computing times
print(mean(round(bf_time, 2)))
print(mean(round(mh_time, 2)))
##########################################
## Single chain plots
##########################################
load("output_trunc_gaussian_single_run.RData")
x <- seq(0, 15, 0.01)
plot(density(bf_chain[[1]]), ylim = c(0, .4), col = "blue", main = " ", xlab = "x")
