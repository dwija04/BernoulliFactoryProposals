accept_rate <- 0
for(i in 2:n)
{
y <- rtruncnorm(1, a = 0, b = Inf, mean = x[i-1], sd = sqrt(var))
#calculating the bounds
c_x <- C_f(y, alpha, beta)
c_y <- C_f(x[i-1], alpha, beta)
C <- c_x / (c_y + c_x)
accept <-0
loops <- 0
#running the Bernoulli factory
while(!accept)
{
loops <- loops + 1
C1 <- rbinom(1, 1, C)
if(C1 == 1)
{
M <- rnorm(1, mean = x[i-1], sd = sqrt(var))
p_x <- (M > 0) #ind(M, x[i-1])
# C2 <- rbinom(1, 1, p_x)
if(p_x== 1)
{
x[i] <- y
accept <- 1
accept_rate <- accept_rate + 1
}
}
else
{
M <- rnorm(1, mean = y, sd = sqrt(var))
p_y <- (M > 0) #ind(M, y)
# C2 <- rbinom(1, 1, p_y)
if(p_y == 1)
{
x[i] <- x[i-1]
accept <- 1
}
}
}
loops_total[i] <- loops
}
return(c(x, loops_total, accept_rate/n))
}
#Running MCMC chain with approximate proposals using Metropolis Hastings
MH_truncnorm <- function(n, alpha = 2, beta = 1,var, init)
{
x <- numeric(n)
x[1] <- init
accept <- 0
for(i in 2:n)
{
y <- rtruncnorm(1, a = 0, b = Inf, mean = x[i-1], sd = sqrt(var))
#Evaluating MH ratio
ratio <- (dgamma(y, shape = alpha, rate = beta) * dtruncnorm(x[i-1], a = 0, b = Inf, mean = y, sd = sqrt(var))) /
(dgamma(x[i-1], shape = alpha, rate = beta) * dtruncnorm(y, a = 0, b = Inf, mean = x[i-1], sd = sqrt(var)))
acceptance_prob <- min(1, ratio)
if(runif(1) < acceptance_prob) {
x[i] <- y
accept <- accept + 1
} else {
x[i] <- x[i-1]
}
}
return(c(x, accept/n))
}
library(truncnorm)
library(mcmcse)
#Gamma (2, 1) target distribution
pi <- function(x, alpha, beta)
{
ret <- x^(alpha-1) * exp(-beta*x)
return(ret)
}
#function to calculate the bounds
C_f <- function(x, alpha, beta)
{
ret <- x^(alpha - 1) * exp((-1)*beta*x)
return(ret)
}
#indicator function
ind <- function(t, x)
{
if(t < x) {ret <- 1}
else {ret <- 0}
return(ret)
}
#Running the MCMC chain with exact proposals using Bernoulli factories
BF_trunc_norm <- function(n, alpha = 2, beta = 1, var, init)
{
x <- numeric(n)
x[1] <- init
loops_total <- numeric(n)
accept_rate <- 0
for(i in 2:n)
{
y <- rtruncnorm(1, a = 0, b = Inf, mean = x[i-1], sd = sqrt(var))
#calculating the bounds
c_x <- C_f(y, alpha, beta)
c_y <- C_f(x[i-1], alpha, beta)
C <- c_x / (c_y + c_x)
accept <-0
loops <- 0
#running the Bernoulli factory
while(!accept)
{
loops <- loops + 1
C1 <- rbinom(1, 1, C)
if(C1 == 1)
{
M <- rnorm(1, mean = x[i-1], sd = sqrt(var))
p_x <- (M > 0) #ind(M, x[i-1])
# C2 <- rbinom(1, 1, p_x)
if(p_x== 1)
{
x[i] <- y
accept <- 1
accept_rate <- accept_rate + 1
}
}
else
{
M <- rnorm(1, mean = y, sd = sqrt(var))
p_y <- (M > 0) #ind(M, y)
# C2 <- rbinom(1, 1, p_y)
if(p_y == 1)
{
x[i] <- x[i-1]
accept <- 1
}
}
}
loops_total[i] <- loops
}
return(c(x, loops_total, accept_rate/n))
}
#Running MCMC chain with approximate proposals using Metropolis Hastings
MH_truncnorm <- function(n, alpha = 2, beta = 1,var, init)
{
x <- numeric(n)
x[1] <- init
accept <- 0
for(i in 2:n)
{
y <- rtruncnorm(1, a = 0, b = Inf, mean = x[i-1], sd = sqrt(var))
#Evaluating MH ratio
ratio <- (dgamma(y, shape = alpha, rate = beta) * dtruncnorm(x[i-1], a = 0, b = Inf, mean = y, sd = sqrt(var))) /
(dgamma(x[i-1], shape = alpha, rate = beta) * dtruncnorm(y, a = 0, b = Inf, mean = x[i-1], sd = sqrt(var)))
acceptance_prob <- min(1, ratio)
if(runif(1) < acceptance_prob) {
x[i] <- y
accept <- accept + 1
} else {
x[i] <- x[i-1]
}
}
return(c(x, accept/n))
}
dnorm(10.05, mean = 10, sd = 0.025)
pnorm(10.05, mean = 10, sd = 0.025)
pnorm(10.05, mean = 10, sd = 0.5)
1 - pnorm(10.05, mean = 10, sd = 0.5)
1 - pnorm(10.05, mean = 10, sd = 0.025)
getwd()
setwd("/Users/dwijakakkad/Desktop/MCMC/Bernoulli factory proposals/Cox_modulated_GP")
##########################################
## Code for reproducing the results from
## the Cox processes example
##########################################
load("cox-data.RData")
load("output_Cox.RData")
ns <- xn[[1]]
xs <- xn[[2]] #generated data
m <- xn[[6]] #number of observations
t <- xn[[4]] #grid
N <- 1e6
reps <- length(output_cox)
#To store outputs
bf_loops_avg <- numeric(reps)
bf_loops_max <- numeric(reps)
bf_MultiESS <- numeric(reps)
bf_time <- numeric(reps)
bf_ess <- matrix(nrow = reps, ncol = m)
mh_MultiESS <- numeric(reps)
mh_time <- numeric(reps)
mh_ess <- matrix(nrow = reps, ncol = m)
for(i in 1:reps)
{
foo <- output_cox[[i]]
bf_time[i] <- foo[[1]]
mh_time[i] <- foo[[2]]
bf_loops_avg[i] <- foo[[3]]
bf_loops_max[i] <- foo[[4]]
bf_MultiESS[i] <- foo[[5]]
mh_MultiESS[i] <- foo[[6]]
bf_ess[i, ] <- foo[[7]]
mh_ess[i, ] <- foo[[8]]
}
print(paste("Average number of mean loops: ", round(mean(bf_loops_avg), 4)))
print(paste("Average number of max loops for: ", round(mean(bf_loops_max), 4)))
bf_mESS_per_unit_time <- bf_MultiESS/bf_time
mh_mESS_per_unit_time <- mh_MultiESS/mh_time
Multi_ESS_df <- data.frame(
Method = c("Bernoulli Factory", "Metropolis Hastings"),
MultiESS = c(round(mean(bf_MultiESS), 0), round(mean(mh_MultiESS), 0)),
MultiESS_by_time = c(round(mean(bf_mESS_per_unit_time), 4), round(mean(mh_mESS_per_unit_time), 4)),
Avg_compute_time = c(round(mean(bf_time), 0), round(mean(mh_time), 0))
)
print(Multi_ESS_df)
avg_ess_bf <- round(colMeans(bf_ess), 0)
avg_ess_mh <- round(colMeans(mh_ess), 0)
ESS_df <- data.frame(
Method = c("Component 1", "Component 2", "Component 3", "Component 4", "Component 5", "Component 6",
"Component 7", "Component 8", "Component 9", "Component 10"),
Bernoulli_ESS = avg_ess_bf,
Auxiliary_ESS = avg_ess_mh
)
print(ESS_df)
source("cox_functions.R")
load("output_cox_single_run.RData")
#PLOTS
delta_m <- 50/(m-1)
grid <- seq(0, 50, length = 100)
est_fun1 <- numeric(length = length(grid))
est_fun2 <- numeric(length = length(grid))
bf_samps <- bf_chain[[1]]
mh_samps <- mh_chain[[1]]
#log posterior
log_post_bf <- bf_chain[[4]]
log_post_mh <- mh_chain[[3]]
#True density
temp <- seq(0, 50, length = 1e4)
y_temp <- (lam1(temp))
pdf("plots/cox-est-density.pdf")
pdf("plots/cox-component-density.pdf")
j <- 1
plot(density(bf_samps[-c(1:1000), j]), col = "blue",
ylab = "Density", xlab = "x", main = "")
lines(density(mh_samps[-c(1:1000), j]), col = "red")
legend("topright", legend = c("Bernoulli factory", "Metropolis-Hastings"),
col = c("blue", "red"), cex = 1.5, lty = 1, lwd = 2, bty = "n")
dev.off()
##########################################
## Code for reproducing the results from
## the Cox processes example
##########################################
load("cox-data.RData"),
##########################################
## Code for reproducing the results from
## the Cox processes example
##########################################
load("cox-data.RData")
load("output_Cox.RData")
ns <- xn[[1]]
xs <- xn[[2]] #generated data
m <- xn[[6]] #number of observations
t <- xn[[4]] #grid
N <- 1e6
reps <- length(output_cox)
#To store outputs
bf_loops_avg <- numeric(reps)
bf_loops_max <- numeric(reps)
bf_MultiESS <- numeric(reps)
bf_time <- numeric(reps)
bf_ess <- matrix(nrow = reps, ncol = m)
mh_MultiESS <- numeric(reps)
mh_time <- numeric(reps)
mh_ess <- matrix(nrow = reps, ncol = m)
for(i in 1:reps)
{
foo <- output_cox[[i]]
bf_time[i] <- foo[[1]]
mh_time[i] <- foo[[2]]
bf_loops_avg[i] <- foo[[3]]
bf_loops_max[i] <- foo[[4]]
bf_MultiESS[i] <- foo[[5]]
mh_MultiESS[i] <- foo[[6]]
bf_ess[i, ] <- foo[[7]]
mh_ess[i, ] <- foo[[8]]
}
print(paste("Average number of mean loops: ", round(mean(bf_loops_avg), 4)))
print(paste("Average number of max loops for: ", round(mean(bf_loops_max), 4)))
bf_mESS_per_unit_time <- bf_MultiESS/bf_time
mh_mESS_per_unit_time <- mh_MultiESS/mh_time
Multi_ESS_df <- data.frame(
Method = c("Bernoulli Factory", "Metropolis Hastings"),
MultiESS = c(round(mean(bf_MultiESS), 0), round(mean(mh_MultiESS), 0)),
MultiESS_by_time = c(round(mean(bf_mESS_per_unit_time), 4), round(mean(mh_mESS_per_unit_time), 4)),
Avg_compute_time = c(round(mean(bf_time), 0), round(mean(mh_time), 0))
)
print(Multi_ESS_df)
avg_ess_bf <- round(colMeans(bf_ess), 0)
avg_ess_mh <- round(colMeans(mh_ess), 0)
ESS_df <- data.frame(
Method = c("Component 1", "Component 2", "Component 3", "Component 4", "Component 5", "Component 6",
"Component 7", "Component 8", "Component 9", "Component 10"),
Bernoulli_ESS = avg_ess_bf,
Auxiliary_ESS = avg_ess_mh
)
print(ESS_df)
j <- 100
plot(density(bf_samps[-c(1:1000), j]), col = "blue",
ylab = "Density", xlab = "x", main = "")
source("cox_functions.R")
load("output_cox_single_run.RData")
load("output_cox_single_run.RData")
#PLOTS
delta_m <- 50/(m-1)
grid <- seq(0, 50, length = 100)
est_fun1 <- numeric(length = length(grid))
est_fun2 <- numeric(length = length(grid))
bf_samps <- bf_chain[[1]]
mh_samps <- mh_chain[[1]]
#log posterior
log_post_bf <- bf_chain[[4]]
log_post_mh <- mh_chain[[3]]
#True density
temp <- seq(0, 50, length = 1e4)
y_temp <- (lam1(temp))
pdf("plots/cox-component-density.pdf")
j <- 100
plot(density(bf_samps[-c(1:1000), j]), col = "blue",
ylab = "Density", xlab = "x", main = "")
lines(density(mh_samps[-c(1:1000), j]), col = "red")
legend("topright", legend = c("Bernoulli factory", "Metropolis-Hastings"),
col = c("blue", "red"), cex = 1.5, lty = 1, lwd = 2, bty = "n")
##########################################
## Code for reproducing the results from
## the Cox processes example
##########################################
load("cox-data.RData")
load("output_Cox.RData")
ns <- xn[[1]]
xs <- xn[[2]] #generated data
m <- xn[[6]] #number of observations
t <- xn[[4]] #grid
source("cox_functions.R")
load("output_cox_single_run.RData")
#PLOTS
delta_m <- 50/(m-1)
grid <- seq(0, 50, length = 100)
est_fun1 <- numeric(length = length(grid))
est_fun2 <- numeric(length = length(grid))
bf_samps <- bf_chain[[1]]
mh_samps <- mh_chain[[1]]
#log posterior
log_post_bf <- bf_chain[[4]]
log_post_mh <- mh_chain[[3]]
#True density
temp <- seq(0, 50, length = 1e4)
y_temp <- (lam1(temp))
pdf("plots/cox-component-density.pdf")
j <- 100
plot(density(bf_samps[-c(1:1000), j]), col = "blue",
ylab = "Density", xlab = "x", main = "")
lines(density(mh_samps[-c(1:1000), j]), col = "red")
j <- 100
plot(density(bf_samps[-c(1:1000), j]), col = "blue",
ylab = "Density", xlab = "x", main = "")
lines(density(mh_samps[-c(1:1000), j]), col = "red")
legend("topright", legend = c("Bernoulli factory", "Metropolis-Hastings"),
col = c("blue", "red"), cex = 1.5, lty = 1, lwd = 2, bty = "n")
j <- 100
##########################################
## Code for reproducing the results from
## the Cox processes example
##########################################
load("cox-data.RData")
load("output_Cox.RData")
ns <- xn[[1]]
xs <- xn[[2]] #generated data
m <- xn[[6]] #number of observations
t <- xn[[4]] #grid
N <- 1e6
reps <- length(output_cox)
#To store outputs
bf_loops_avg <- numeric(reps)
bf_loops_max <- numeric(reps)
bf_MultiESS <- numeric(reps)
bf_time <- numeric(reps)
bf_ess <- matrix(nrow = reps, ncol = m)
mh_MultiESS <- numeric(reps)
mh_time <- numeric(reps)
mh_ess <- matrix(nrow = reps, ncol = m)
for(i in 1:reps)
{
foo <- output_cox[[i]]
bf_time[i] <- foo[[1]]
mh_time[i] <- foo[[2]]
bf_loops_avg[i] <- foo[[3]]
bf_loops_max[i] <- foo[[4]]
bf_MultiESS[i] <- foo[[5]]
mh_MultiESS[i] <- foo[[6]]
bf_ess[i, ] <- foo[[7]]
mh_ess[i, ] <- foo[[8]]
}
print(paste("Average number of mean loops: ", round(mean(bf_loops_avg), 4)))
print(paste("Average number of max loops for: ", round(mean(bf_loops_max), 4)))
bf_mESS_per_unit_time <- bf_MultiESS/bf_time
mh_mESS_per_unit_time <- mh_MultiESS/mh_time
Multi_ESS_df <- data.frame(
Method = c("Bernoulli Factory", "Metropolis Hastings"),
MultiESS = c(round(mean(bf_MultiESS), 0), round(mean(mh_MultiESS), 0)),
MultiESS_by_time = c(round(mean(bf_mESS_per_unit_time), 4), round(mean(mh_mESS_per_unit_time), 4)),
Avg_compute_time = c(round(mean(bf_time), 0), round(mean(mh_time), 0))
)
print(Multi_ESS_df)
avg_ess_bf <- round(colMeans(bf_ess), 0)
avg_ess_mh <- round(colMeans(mh_ess), 0)
ESS_df <- data.frame(
Method = c("Component 1", "Component 2", "Component 3", "Component 4", "Component 5", "Component 6",
"Component 7", "Component 8", "Component 9", "Component 10"),
Bernoulli_ESS = avg_ess_bf,
Auxiliary_ESS = avg_ess_mh
)
print(ESS_df)
source("cox_functions.R")
load("output_cox_single_run.RData")
#PLOTS
delta_m <- 50/(m-1)
grid <- seq(0, 50, length = 100)
est_fun1 <- numeric(length = length(grid))
est_fun2 <- numeric(length = length(grid))
bf_samps <- bf_chain[[1]]
mh_samps <- mh_chain[[1]]
#log posterior
log_post_bf <- bf_chain[[4]]
log_post_mh <- mh_chain[[3]]
#True density
temp <- seq(0, 50, length = 1e4)
y_temp <- (lam1(temp))
pdf("plots/cox-component-density.pdf")
j <- 100
plot(density(bf_samps[-c(1:1000), j]), col = "blue", ylab = "Density", xlab = "x", main = "")
lines(density(mh_samps[-c(1:1000), j]), col = "red")
legend("topright", legend = c("Bernoulli factory", "Metropolis-Hastings"), col = c("blue", "red"), cex = 1.5, lty = 1, lwd = 2, bty = "n")
dev.off()
j <- 100
plot(density(bf_samps[-c(1:1000), j]), col = "blue", ylab = "Density", xlab = "x", main = "")
##########################################
## Code for reproducing the results from
## the Cox processes example
##########################################
load("cox-data.RData")
load("output_Cox.RData")
ns <- xn[[1]]
xs <- xn[[2]] #generated data
m <- xn[[6]] #number of observations
t <- xn[[4]] #grid
N <- 1e6
reps <- length(output_cox)
#To store outputs
bf_loops_avg <- numeric(reps)
bf_loops_max <- numeric(reps)
bf_MultiESS <- numeric(reps)
bf_time <- numeric(reps)
bf_ess <- matrix(nrow = reps, ncol = m)
mh_MultiESS <- numeric(reps)
mh_time <- numeric(reps)
mh_ess <- matrix(nrow = reps, ncol = m)
for(i in 1:reps)
{
foo <- output_cox[[i]]
bf_time[i] <- foo[[1]]
mh_time[i] <- foo[[2]]
bf_loops_avg[i] <- foo[[3]]
bf_loops_max[i] <- foo[[4]]
bf_MultiESS[i] <- foo[[5]]
mh_MultiESS[i] <- foo[[6]]
bf_ess[i, ] <- foo[[7]]
mh_ess[i, ] <- foo[[8]]
}
print(paste("Average number of mean loops: ", round(mean(bf_loops_avg), 4)))
print(paste("Average number of max loops for: ", round(mean(bf_loops_max), 4)))
bf_mESS_per_unit_time <- bf_MultiESS/bf_time
mh_mESS_per_unit_time <- mh_MultiESS/mh_time
Multi_ESS_df <- data.frame(
Method = c("Bernoulli Factory", "Metropolis Hastings"),
MultiESS = c(round(mean(bf_MultiESS), 0), round(mean(mh_MultiESS), 0)),
MultiESS_by_time = c(round(mean(bf_mESS_per_unit_time), 4), round(mean(mh_mESS_per_unit_time), 4)),
Avg_compute_time = c(round(mean(bf_time), 0), round(mean(mh_time), 0))
)
print(Multi_ESS_df)
avg_ess_bf <- round(colMeans(bf_ess), 0)
avg_ess_mh <- round(colMeans(mh_ess), 0)
ESS_df <- data.frame(
Method = c("Component 1", "Component 2", "Component 3", "Component 4", "Component 5", "Component 6",
"Component 7", "Component 8", "Component 9", "Component 10"),
Bernoulli_ESS = avg_ess_bf,
Auxiliary_ESS = avg_ess_mh
)
print(ESS_df)
source("cox_functions.R")
load("output_cox_single_run.RData")
#PLOTS
delta_m <- 50/(m-1)
grid <- seq(0, 50, length = 100)
est_fun1 <- numeric(length = length(grid))
est_fun2 <- numeric(length = length(grid))
bf_samps <- bf_chain[[1]]
mh_samps <- mh_chain[[1]]
#log posterior
log_post_bf <- bf_chain[[4]]
log_post_mh <- mh_chain[[3]]
#True density
temp <- seq(0, 50, length = 1e4)
y_temp <- (lam1(temp))
pdf("plots/cox-component-density.pdf")
j <- 100
plot(density(bf_samps[-c(1:1000), j]), col = "blue", ylab = "Density", xlab = "x", main = "")
lines(density(mh_samps[-c(1:1000), j]), col = "red")
legend("topright", legend = c("Bernoulli factory", "Metropolis-Hastings"), col = c("blue", "red"), cex = 1.5, lty = 1, lwd = 2, bty = "n")
dev.off()
